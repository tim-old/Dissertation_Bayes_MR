# (APPENDIX) Appendix {-} 

\newpage

```{r setup9, include=FALSE}

knitr::opts_chunk$set(echo = TRUE,
                      include = TRUE,
                      warning=FALSE, 
                      message=FALSE, 
                      error=FALSE,
                      cache = TRUE,
                      dev = "png", 
                      dpi = 500
)

# Load packages
library(tidyverse)
library(dplyr) #bookdown not finding if_else
library(magrittr) #bookdown not finding %>%
library(bookdown)
library(here)
library(cowplot)
library(kableExtra)
library(acronymsdown)
library(grateful)

# Load University of Edinburgh colour palette
source(here::here("Script", "edin_uni_colours.R"))

# Load pre-formatted plot template - call to ggplot with UoE colours
source(here::here("Script", "edin_fig_style.R"))


```
# Appendix: List of Abbreviations {#appendix-acr}


\printacronyms


\newpage

# Appendix: Bootstrapping {#appendix-boot}

## Bootstrapping - General Method

Estimating the true value of a population parameter from a smaller sample of the population inherently involves uncertainty. Unless data are gathered from all members of the population, it is always possible that population members excluded from a sample will be poorly represented by the population members included in the sample. The typical process for "bootstrap" generating an estimate, \acr{SE} and \acr{CI}s of a population parameter (e.g. population mean $\mu$) from a sample $x$ is as follows[@buscaglia_chapter_2020]:

1. A sample, $x$, of $n$ individuals is selected from a total population, $X$, of $N$ individuals
2. This sample $x$ is then treated as the "bootstrap population"; the empirical distribution of values in the $n$ individuals in the bootstrap population is taken to be broadly representative of the distribution of values in the underlying population $X$ of $N$ individuals
3. A "bootstrap sample", $x^*$,  is then obtained by re-sampling individuals from the bootstrap population with replacement $n$ times per bootstrap sample, i.e. the new bootstrap sample comprises $n$ sampled individuals, $x^*_1, x^*_2,...x^*_n$. As such, individuals from the original bootstrap population $x$ may contribute once, more than once or not at all to each bootstrap sample $x^*$.
4. A total of $k$ bootstrap samples are generated, $x^{*1}, x^{*2},...x^{*k}$, and the statistic of interest (e.g. sample mean $\bar{x}$) is estimated in each individual sample, $\bar{x}^{*i}$, giving the complete set of $\bar{x}^{*1}, \bar{x}^{*2},...\bar{x}^{*i}...\bar{x}^{*k}$.
5. The set of $k$ statistics are combined to form a "bootstrap distribution"; as expected from \acr{CLT}[@ross_chapter_2014], this is typically closer to a normal distribution than the underlying distribution of values in either the bootstrap population $x$ or the total population $X$. (See Figure \@ref(fig:prostate-vol) for an example of this)
6. The final values are derived as follows:

> - the parameter estimate (e.g. estimate of the true population mean, $\hat{\mu}$) is taken as the mean of the bootstrap distribution of $k$ estimates, $\hat{\mu} = (\sum^k_{i = 1} \bar{x}) \div k$
> - the \acr{CI}s are taken as the values at the appropriate centiles at the edges of the sampling distribution, e.g. a 95% \acr{CI} would be generated using values at the 2.5th and 97.5th centiles
> - the \acr{SE} of the estimate is taken as the \acr{SD} of the sampling distribution, given by $\sqrt{\frac{1}{k - 1} \sum^k_{i = 1} (\bar{x_i} - \hat{\mu})^2}$



## Bootstrapping - Example: Prostate Volume

The above process is illustrated in \@ref(fig:prostate-vol). Data on prostate volume in 307 prostate cancer patients demonstrates a right-skewed distribution (A). An empirical distribution from a sample of 100 of these patients mirrors this right skew, and is used as the "bootstrap population" (B) for further re-sampling. As the bootstrap population is re-sampled more and more times, the "bootstrap distribution" of the sample means generated (C and D) gradually tends towards a normal distribution. The 95% \acr{CI} is given by the bounds defining the middle 95% of the bootstrap distribution of estimated means, as shown.

```{r prostate-vol, echo=FALSE, include=TRUE, fig.dim = c(6, 7.5)}
#| fig.id = 'prostate-vol',
#| fig.cap = "Histograms demonstrating distribution of prostate volumes in patients with prostatic cancer, taken from Cata et al 2011[@cata_blood_2011] via the R package `medicaldata`[@medicaldata]. A) Distribution from whole study population of 307 patients with non-missing data, exhibiting right-skew. B) Distribution from random sample of 100 patients, still exhibiting right-skew. C) Bootstrap distribution generated by re-sampling 1,000 bootstrap samples from the original sample of 100 patients, right-skew less apparent. D) Bootstrap distribution generated by re-sampling 100,000 bootstrap samples from the original sample of 100 patients, approaching normality. 95% confidence intervals are demonstrated in plots C and D by marking the 2.5th and 97.5th centiles."


library(medicaldata)
library(infer)
library(gghighlight)

prostate_vol_pop <- blood_storage %>% 
  plot_template() +
  geom_histogram(aes(x = PVol), 
                 binwidth = 2,
                 #y = stat(density)),
                 fill = edin_blue_hex) +
  labs(subtitle = "A) True distribution, N = 307",
       x = NULL) +
  xlim(10, 275) +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=0.5))

set.seed(1701)
prostate_vol_samp <- blood_storage %>% 
  slice_sample(n = 100) %>% 
  plot_template() +
  geom_histogram(aes(x = PVol), 
                 binwidth = 2,
                 #y=stat(density)),
                 fill = edin_blue_hex) +
  labs(subtitle = "B) Empirical distribution, n = 100",
       x = NULL) +
  xlim(10, 275) +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=0.5))

set.seed(1701)
prostate_vol_boot_1k <- blood_storage %>% 
  slice_sample(n = 100) %>% 
  specify(response = PVol) %>% 
  generate(reps = 1000, 
           type = "bootstrap") %>% 
  calculate(stat = "mean") %>% 
  # Calc CIs
  mutate(lower = quantile(stat, 0.025),
         upper = quantile(stat, 0.975)) %>% 
  plot_template() +
  geom_histogram(aes(x = stat),
                 binwidth = 2,
                 #y=stat(density)),
                 fill = edin_blue_hex) +
  # Plot CIs
  gghighlight(stat > lower & stat < upper,
              unhighlighted_params = list(fill = edin_burgundy_hex)) +
  labs(subtitle = "C) Bootstrap distribution, k = 1,000",
       x = NULL) +
  xlim(10, 275) +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=0.5))

set.seed(1701)
prostate_vol_boot_100k <- blood_storage %>% 
  slice_sample(n = 100) %>% 
  specify(response = PVol) %>% 
  generate(reps = 100000, 
           type = "bootstrap") %>% 
  calculate(stat = "mean") %>% 
  # Calc CIs
  mutate(lower = quantile(stat, 0.025),
         upper = quantile(stat, 0.975)) %>% 
  plot_template() +
  geom_histogram(aes(x = stat),
                stat = "bin", 
                binwidth = 2,
                #y=stat(density)),
                fill = edin_blue_hex) +
  # Plot CIs
  gghighlight(stat > lower & stat < upper,
              unhighlighted_params = list(fill = edin_burgundy_hex)) +
  labs(subtitle = "D) Bootstrap distribution, k = 100,000",
       x = "Prostate volume/mL") +
  xlim(10,275) +
  theme(axis.text.y = element_text(angle = 90, vjust = 0.5, hjust=0.5))


cowplot::plot_grid(prostate_vol_pop, 
                   prostate_vol_samp,
                   prostate_vol_boot_1k,
                   prostate_vol_boot_100k,
                   ncol = 1,
                   rel_heights = c(1,1,1,1.3)
                   )

```

\newpage

## Bootstrapping - Relevance to WME

In current implementations of \acr{WME}, the \acr{WME} estimate of the causal effect ($\hat{\beta}_{WME}$) is calculated as described in Bowden et al[@bowden_consistent_2016], and the 95% \acr{CI} is generated separately using what is described as a bootstrapping approach. However, the implementation of this deviates from the standard bootstrapping methodology described above.

\acr{CI}s for \acr{WME} are generated in the following way (see [Web Appendix 2](https://research-information.bris.ac.uk/ws/portalfiles/portal/101612595/Bowden_et_al_2016_Genetic_Epidemiology.sup_1.pdf) from the original paper[@bowden_consistent_2016] for full code):

1. Summary data (estimates of gene-exposure coefficient $\hat{\gamma}$, gene-outcome coefficient $\hat{\Gamma}$, and their respective standard errors) are obtained for a sample $x$ of $n$ genetic instruments, $G_1, G_2...G_j...G_n$.
2. For each instrument $G_j$ in $x$, a normal distribution is created centered on the input gene-exposure coefficient estimate $\hat{\gamma_j}$, with the \acr{SD} of this distribution set equal to the \acr{SE} of the estimate, $SE({\hat{\gamma_j}})$.
3. Each of these normal distributions $\mathcal{N}(\space \hat{\gamma_j}, \space SE({\hat{\gamma_j}})\space)$ is treated as a bootstrap population for estimating the gene-exposure coefficient and standard error for its respective instrument. Each instrument is re-sampled a default of $k = 1000$ times from its bootstrap population, forming a bootstrap distribution of $k$ estimates of the gene-exposure coefficient for each instrument, $\hat{\gamma}_j^{*1}, \hat{\gamma}_j^{*2}...\hat{\gamma}_j^{*k}$
4. Steps $2.$ and $3.$ are repeated using gene-outcome coefficients and their \acr{SE}s
5. For each instrument, a Wald estimate of causal effect, $\hat{\beta_j} = \frac{\hat{\Gamma}_j}{\hat{\gamma}_j}$ is obtained from each of the $k$ pairs of gene-exposure and gene-outcome coefficients, $\hat{\beta_j}^{*1}, \hat{\beta_j}^{*2}...\hat{\beta_j}^{*k}$
6. A weighted median causal estimate is calculated from each of the $k$ sets of Wald estimates, $\hat{\beta}_{WME}^{*1}, \hat{\beta}_{WME}^{*2}...\hat{\beta}_{WME}^{*k}$, or $(\hat{\beta}_{WME}^{*i})_{i=1}^k$
7. The standard deviation of the $k$ bootstrapped values of $(\hat{\beta}_{WME}^{*i})_{i=1}^k$ is taken as the bootstrapped standard error $SE^*$ of the empiric/observed \acr{WME} causal estimate, $\hat{\beta}_{WME}$. The 95% \acr{CI} is then calculated as $\hat{\beta}_{WME} \pm 1.96  \times SE^*$

This approach differs from typical bootstrapping methodology in several regards. Of particular note, gene-exposure and gene-outcome coefficients are re-sampled from normal distributions _for a given set of instruments_. This approach may adequately account for some random error in the estimation of these coefficients, but it does not account for the distribution or magnitude of pleiotropic effects. A re-sampling approach could account for pleiotropy-related uncertainty, but this would require re-sampling of the instruments themselves, which is difficult to implement in practice. 

Given that this method of \acr{CI} generation does not account for an important source of uncertainty, it would be expected to be over-confident and produce \acr{CI}s which are too narrow. Narrow \acr{CI}s are less likely to include the null value, and therefore this may lead to higher rates of causality being reported when using this method, even when no true causal effect exists. As such, incorrect \acr{CI} generation may therefore contribute to a higher Type 1 error rate when using \acr{WME} than might otherwise be expected. 

\newpage

# Appendix: Simulation Code {#appendix-sim}


## Generating Data and Models {#appendix-sim-gen}

The data generating model used was from Appendix 3 of Bowden et al [@bowden_consistent_2016]; the relevant section describing their model is reproduced below:

>_"..._

>\begin{equation} 
U_i = \sum^J_{j=1} \phi_jG_{ij} + \epsilon_i^U
\end{equation}


>\begin{equation} 
X_i = \sum^J_{j=1} \gamma_jG_{ij} + U_i + \epsilon_i^X
\end{equation}

>\begin{equation} 
Y_i = \sum^J_{j=1} \alpha_jG_{ij} + \beta X_i + U_i + \epsilon_i^Y
\end{equation}

>_for participants indexed by $i = 1, . . . , N$, and genetic instruments indexed by $j = 1, . . . , J$._

>_The error terms $\epsilon_i^U , \epsilon_i^X$ and $\epsilon_i^Y$ were each drawn independently from standard normal distributions. The genetic effects on the exposure γj are drawn from a uniform distribution between 0.03 and 0.1. Pleiotropic effects $\alpha_j$ and $\phi_j$ were set to zero if the genetic instrument was a valid instrumental variable. Otherwise (with probability 0.1, 0.2, or 0.3):_

>_1. In Scenario 1 (balanced pleiotropy, InSIDE satisfied), the $\alpha_j$ parameter was drawn from a uniform distribution between −0.2 and 0.2._

>_2. In Scenario 2 (directional pleiotropy, InSIDE satisfied), the $\alpha_j$ parameter was drawn from a uniform distribution between 0 and 0.2._ 

>_3. In Scenario 3 (directional pleiotropy, InSIDE not satisfied), the $\phi_j$ parameter was drawn from a uniform distribution between −0.2 and 0.2._


>_The causal effect of the exposure on the outcome was either $\beta X = 0$ (null causal effect) or $\beta X = 0.1$ (positive causal effect). A total of 10 000 simulated datasets were generated for sample sizes of N = 10 000 and 20 [sic] participants. Only the summary data, that is genetic associations with the exposure and with the outcome and their standard errors as estimated by univariate regression on the genetic instruments in turn, were used by the analysis methods. In the two-sample setting, data were generated on 2N participants, and genetic associations with the exposure were estimated in the first N participants, and genetic associations with the outcome in the second N participants."_ [@bowden_consistent_2016]

To reproduce this model, code was written in R to generate the relevant participant level data. First, a function (`get_simulated_MR_data`) was written which included parameters specified by Bowden et al, and also to allow testing of data simulation:



```{r wme-model-fn, echo=TRUE}

# Define function to create data generating model
# Arguments/default values based on Bowden et al
get_simulated_MR_data <- function(n_participants = as.integer(), 
                                  n_instruments = as.integer(),
                                  n_datasets = as.integer(),
                                  prop_invalid = 0.1,
                                  causal_effect = TRUE,
                                  balanced_pleio = TRUE,
                                  InSIDE_satisfied = TRUE,
                                  rand_error = TRUE,      # remove random errors, for testing
                                  two_sample = TRUE,      # 1- or 2-sample MR toggle, for testing
                                  beta_val = 0.1,         # size of causal effect
                                  allele_freq_min = 0.4,  # frequency of effect allele 0.01/0.99
                                  allele_freq_max = 0.6,  #?0.4/0.6
                                  gamma_min = 0.03,       # size of genetic effects on exposure
                                  gamma_max = 0.1,
                                  alpha_min = -0.2,       # size of pleiotropic effects on outcome
                                  alpha_max = 0.2,
                                  phi_min = -0.2,         # size of additional pleiotropic effects
                                  phi_max = 0.2,          # when InSIDE not satisfied
                                  seed = 14101583){       # Set seed for reproducibility
  
  # Set seed to ensure comparability across scenarios
  set.seed(seed)
  
  # Initialise blank lists to receive datasets for
  # each of:
  #     U (vector: unmeasured confounding exposures per participant), 
  #     X (vector: exposure:outcome associations estimated per participant) 
  #     Y (vector: gene:outcome association estimated per participant), 
  #     G (Matrices: Genotype data)
  #
  #     gamma (vector: pleiotropic effects of each instrument on exposure)
  #     alpha (vector: pleiotropic effects of each instrument on outcome)
  #     phi (vector: additional pleiotropic effects of each instrument when InSIDE 
  #     assumption not satisfied)
  U_list <- list()
  X_list <- list()
  Y_list <- list()
  G_X_list <- list()
  G_Y_list <- list()
  
  gamma_list <- list()
  alpha_list <- list()
  phi_list <- list()

  
  n_participants_list <- list()
  n_instruments_list <- list()
  prop_invalid_list <- list()
  beta_val_list <- list()

  
  
  # --- Assign features common to all datasets --- #
  
  # size of causal effect
  beta <- if_else(causal_effect == TRUE, 
                  beta_val,
                  0)
  
  # create vector of participant indices for 1st n participants
  # i.e. participants used for estimating gene:exposure coefficient
  sample_1_ref <- 1:n_participants        
  
  
  # Default is to estimate gene:outcome coefficient from different sample
  # to gene:exposure coefficient (i.e. simulating 2-sample MR)
  # two_sample == FALSE toggles to single sample for testing simulation
  ifelse(two_sample == FALSE,
         sample_2_ref <- sample_1_ref, # 1 sample MR
         sample_2_ref <- (n_participants+1):(2*n_participants)) # 2 sample MR
  
  # --- Set characteristics for each genetic instrument --- # 
  
  # Set genetic effects of each instrument on the exposure,
  # drawn from uniform distribution, min/max as per Bowden 
  # et al
  gamma_vect <- runif(n = n_instruments,
                      min = gamma_min,
                      max = gamma_max)
  
  
  
  # Set which instruments invalid, 0 = valid, 1 = invalid
  invalid_instrument_vect <- rbinom(n = n_instruments,
                                    size = 1, 
                                    prob = prop_invalid)
  
  
  # Probability of effect allele set per dataset  
  # for each instrument, default value set at  
  # random between 0.4-0.6 (i.e. both effect +
  # reference are common alleles)
  allele_freq_vect <- runif(n = n_instruments,
                            min = allele_freq_min,
                            max = allele_freq_max)
  
  # Set pleiotropic effects on outcome, Scenarios and 
  # min/max from Bowden et al
  alpha_vect <- double() # Pleiotropic effects of instruments on outcome
  phi_vect <- double() # Pleiotropic effects of confounders on outcome
  
  
  for(j in 1:n_instruments){
    ifelse(invalid_instrument_vect[j] == 0, # alpha = 0 if valid
           alpha_vect[j] <- 0,
           ifelse(balanced_pleio == TRUE,
                  alpha_vect[j] <- runif(n = 1, # balanced
                                         min = alpha_min,
                                         max = alpha_max),
                  alpha_vect[j] <- runif(n = 1, # directional
                                         min = 0,
                                         max = alpha_max)
           )
    )
    

    # Assign default phi = 0 unless directional pleiotropy & 
    # InSIDE assumption not satisfied & genetic instrument invalid
    if(balanced_pleio == FALSE & InSIDE_satisfied == FALSE){
      ifelse(invalid_instrument_vect[j] == 0,
             phi_vect[j] <- 0,
             phi_vect[j] <- runif(n = 1,
                                  min = phi_min,
                                  max = phi_max)
      )
      
    }
    else{
      phi_vect[j] <- 0
    }
  }
  
  # Re-set seed to ensure consistency across datasets
  # N.B. above two if/ifelse statements cause de-sync 
  # of number of randomised functions between valid/invalid
  set.seed(seed)
  
  # --- Create separate datasets --- #
  
  # Create N datasets by simulating genotype matrices with
  # 1 row per participant, 1 column per genetic instrument
  # Use these to estimate U, X + Y
  
  for(n in 1:n_datasets){
    
    # --- Create matrix of genotypes --- #

    # Assign genotypes by sampling from binomial distribution
    # twice (as two alleles) per participant with probability
    # equal to frequency of effect allele
    # Create twice as many genotypes as participants in sample
    # to simulate 2 sample MR, i.e. first half used to estimate
    # Gene:Exposure, second half used to estimate Gene:Outcome
    
    # Matrix where columns are instruments, rows are participants
    # Values 0, 1 or 2
    # 0 = reference, i.e. zero effect alleles, 
    # 1 = 1 effect allele, 2 = 2 effect alleles 
    
    G_mat <- matrix(rbinom(n = 2 * n_participants * n_instruments,
                           size = 2,
                           prob = rep(allele_freq_vect, 2 * n_participants)),
                    nrow = 2 * n_participants,
                    ncol = n_instruments,
                    byrow = TRUE)
    
    
    # Create error terms for U, X + Y per participant,
    # each drawn from standard normal distribution
    # unless random error turned off (for testing)
    
    ifelse(rand_error == TRUE,
           U_epsilon_vect <- rnorm(n = 2 * n_participants),
           U_epsilon_vect <- rep(0, 2 * n_participants))
    
    ifelse(rand_error == TRUE,
           X_epsilon_vect <- rnorm(n = n_participants),
           X_epsilon_vect <- rep(0, n_participants))
    
    ifelse(rand_error == TRUE,
           Y_epsilon_vect <- rnorm(n = n_participants),
           Y_epsilon_vect <- rep(0, n_participants))
    
    
    # --- Combine Gene matrix/parameters to recreate model --- #
    
    # Create vectors of estimates for U, X and Y per individual,
    # i.e. Ui, Xi and Yi. Uses matrix inner product operator " %*%" 
    # https://stackoverflow.com/questions/22060515/the-r-operator 
    # http://matrixmultiplication.xyz/

    #     U (vector: unmeasured confounding exposures per participant), 
    #     X (vector: exposure:outcome associations estimated per participant) 
    #     Y (vector: gene:outcome association estimated per participant) 
    
    Ui_vect <-  G_mat %*% phi_vect + U_epsilon_vect
    
    Xi_vect <-  G_mat[sample_1_ref, ] %*% gamma_vect + 
      Ui_vect[sample_1_ref, ] + 
      X_epsilon_vect
    
    Yi_vect <-  G_mat[sample_2_ref, ] %*% alpha_vect + 
      beta * Xi_vect + 
      Ui_vect[sample_2_ref, ] + 
      Y_epsilon_vect
    
    
    # Add vectors of estimates from this dataset to lists of 
    # estimates from all datasets
    U_list[[n]] <- Ui_vect
    
    X_list[[n]] <- Xi_vect
    
    Y_list[[n]] <- Yi_vect
    
    G_X_list[[n]] <- G_mat[sample_1_ref, ]
    
    G_Y_list[[n]] <- G_mat[sample_2_ref, ]
    
    
    # Include actual parameter values generated for simulation 
    alpha_list[[n]] <- alpha_vect
    
    gamma_list[[n]] <- gamma_vect
    
    phi_list[[n]] <- phi_vect
    
    # Include inputs for reference/testing 
    n_participants_list[[n]] <- n_participants
    n_instruments_list[[n]] <- n_instruments
    prop_invalid_list[[n]] <- prop_invalid
    beta_val_list[[n]] <- beta_val
   
     
  }
  
  
  
  # --- Combine all outputs to return --- #
  
  combined_list <- list(U = U_list,         # Estimates 
                        X = X_list, 
                        Y = Y_list,
                        
                        G_X = G_X_list,     # Genotypes of 1st sample
                        G_Y = G_Y_list,     # Genotypes of 2nd sample
                        
                        alpha = alpha_list, # Actual values for validating simulation
                        gamma = gamma_list,
                        phi = phi_list,
                        
                        n_participants = n_participants_list, # Inputs
                        n_instruments = n_instruments_list,
                        prop_invalid = prop_invalid_list,
                        beta_val = beta_val_list
  )
  
  return(combined_list)
}

```

This initial simulation function generated data in the following format:

```{r test-data-sim, echo = TRUE, include = TRUE}

# Check data produced in expected format
#set.seed(1701)
test_data_sim <- get_simulated_MR_data(n_participants = 1000,
                                       n_instruments = 25,
                                       n_datasets = 2,
                                       prop_invalid = 0.3,
                                       rand_error = FALSE,
                                       causal_effect = TRUE,
                                       balanced_pleio = TRUE,
                                       InSIDE_satisfied = TRUE)

str(test_data_sim)

```


A function (`get_models`) was then written to create linear models from each dataset generated as per Bowden et al:


```{r get-models-fn, echo=TRUE}


# Create plotting tibble with Mean/SD X + Y grouped by
# Dataset + instrument
get_models <- function(sim){
    
  output_list <- list()
  
  # Create linear models per dataset to get coefficients
  # for gene:exposure association (coeff_G_X) and gene:outcome
  # association (coeff_G_Y)
  for(dataset in 1:length(sim$X)){
    
    X <- sim$X[[dataset]]
    Y <- sim$Y[[dataset]]
    Instruments_X <- sim$G_X[[dataset]]
    Instruments_Y <- sim$G_Y[[dataset]]
    
    alpha <- sim$alpha[[dataset]]
    gamma <- sim$gamma[[dataset]]
    phi <- sim$phi[[dataset]]
    beta <- sim$beta_val[[dataset]]
    prop_invalid <- sim$prop_invalid[[dataset]]
    n_instruments <- sim$n_instruments[[dataset]]
    n_participants<- sim$n_participants[[dataset]]
    
    
    # Model for gene:exposure
    X_lm <- lm(X ~ 0 + Instruments_X)
    coeff_G_X_vect <- coef(summary(X_lm))[1:(ncol(Instruments_X)), 1]
    SE_coeff_G_X_vect <- coef(summary(X_lm))[1:(ncol(Instruments_X)), 2]
    
    R2_stat <- summary(lm(X ~ Instruments_X))$r.squared
    F_stat <- summary(lm(X ~ Instruments_X))$fstatistic[[1]]

    
    # Model for gene:outcome
    Y_lm <- lm(Y ~ 0 + Instruments_Y)
    coeff_G_Y_vect <- coef(summary(Y_lm))[1:(ncol(Instruments_Y)), 1] 
    SE_coeff_G_Y_vect <- coef(summary(Y_lm))[1:(ncol(Instruments_Y)), 2]
    
    output_list[[dataset]] <- as_tibble(list(dataset = dataset,
                                             Instrument = c(1:ncol(Instruments_X)),
                                             coeff_G_X = coeff_G_X_vect,
                                             coeff_G_X_SE = SE_coeff_G_X_vect,
                                             gamma = gamma,
                                             F_stat = F_stat,
                                             R2_stat = R2_stat,
                                             coeff_G_Y = coeff_G_Y_vect,
                                             coeff_G_Y_SE = SE_coeff_G_Y_vect,
                                             alpha = alpha,
                                             phi = phi,
                                             beta = beta,
                                             prop_invalid = prop_invalid,
                                             n_instruments = n_instruments,
                                             n_participants = n_participants),
                                        .name_repair = "unique")
  }
  
  return(output_list)
  
}  


```


These models generated estimates of the coefficient of gene-exposure association (`coeff_G_X`), coefficient of gene-outcome association (`coeff_G_Y`), and the relevant standard errors of these estimates. The values of parameters inputted were also returned to aid in further testing of data/model generation, i.e. actual gene-exposure associations (`gamma`), pleiotropic effects of invalid instruments (`alpha`), additional pleiotropic effects when \acr{InSIDE} assumption not satified (`phi`), causal effect of exposure on outcome (`beta`) and the proportion of invalid genetic instruments with pleiotropic effects on the outcome (`prop_invalid`).

```{r test-get-model, echo = TRUE, include = TRUE}

test_extract_model <- get_models(test_data_sim)

summary(test_extract_model[[1]])

```


\newpage
## Testing Generation of Data and Models {#appendix-sim-test}

A series of test plots were used to verify that data were simulated as intended under the various conditions specified by input parameters. Test plots were not created for the parameters `n_participants`, `n_instruments` or `n_datasets`, as the functioning of these parameters could be readily inferred from the structure of the  datasets outputted, as above.

### Proportion of Invalid Instruments
\leavevmode\newline The `prop_invalid` parameter specifies the proportion of invalid genetic instruments simulated, i.e. the proportion of genetic instruments affecting the outcome via direct/pleiotropic effects, and thus not solely via the exposure of interest. If simulated correctly, increasing the value of `prop_invalid` should increase the number of instruments with pleiotropic effects, i.e. instruments with `alpha` $\ne$ 0. With random error terms set to 0 and no causal effect present (i.e. `rand_error = FALSE` and `causal_effect = FALSE`), the estimated gene-outcome coefficient estimated using any given instrument will equal the pleiotropic effects of that instrument (i.e. `coeff_G_Y = alpha`), and therefore will only be non-zero for invalid instruments with non-zero pleiotropic effects on the outcome . Plotting `coeff_G_Y` against `alpha` for simulated data with no causal effect or random error should therefore yield a graph where

- For valid instruments: gene-outcome coefficient = alpha = 0
- For invalid instruments:  gene-outcome coefficient = alpha $\ne$  0, with values spread uniformly between `alpha_min` and `alpha_max`


```{r test-plot-prop-invalid, echo=FALSE, include = TRUE}

# Check altering proportion of invalid instruments alters 
# proportion of instruments displaying pleiotropic effects
# N.B. cluster around alpha = 0 represents valid instruments with
# no pleiotropic effects

# 10% of instruments invalid
#set.seed(1701)
sim_test_data_inval_0.1 <- get_simulated_MR_data(n_participants = 1000,
                                                 n_instruments = 25,
                                                 n_datasets = 1,
                                                 prop_invalid = 0.1, 
                                                 rand_error = FALSE,
                                                 causal_effect = FALSE,
                                                 alpha_min = -0.2,
                                                 alpha_max = 0.2)

# 30% of instruments invalid
#set.seed(1701)
sim_test_data_inval_0.3 <- get_simulated_MR_data(n_participants = 1000,
                                                 n_instruments = 25,
                                                 n_datasets = 1,
                                                 prop_invalid = 0.3, 
                                                 rand_error = FALSE,
                                                 causal_effect = FALSE,
                                                 alpha_max = 0.2)

# 50% of instruments invalid
#set.seed(1701)
sim_test_data_inval_0.5 <- get_simulated_MR_data(n_participants = 1000,
                                                 n_instruments = 25,
                                                 n_datasets = 1,
                                                 prop_invalid = 0.5,
                                                 rand_error = FALSE,
                                                 causal_effect = FALSE,
                                                 alpha_min = -0.2,
                                                 alpha_max = 0.2)


test_plot_tib_inval_0.1 <- get_models(sim_test_data_inval_0.1)[[1]]
test_plot_tib_inval_0.3 <- get_models(sim_test_data_inval_0.3)[[1]]
test_plot_tib_inval_0.5 <- get_models(sim_test_data_inval_0.5)[[1]]

test_plot_inval_0.1 <- test_plot_tib_inval_0.1 %>% 
  select(alpha, coeff_G_Y) %>% 
  plot_template() +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  aes(x = alpha, y = coeff_G_Y ) +
  scale_y_continuous(limits = c(-0.2, 0.2)) +
  scale_x_continuous(limits = c(-0.2, 0.2)) +
  labs(y = "Observed Gene-Outcome Coefficient",
       title = "10% of 25 \nInstruments Invalid",
       caption = ""
  ) 

test_plot_inval_0.3 <- test_plot_tib_inval_0.3 %>% 
  select(alpha, coeff_G_Y) %>% 
  plot_template() +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  aes(x = alpha, y = coeff_G_Y ) +
  scale_y_continuous(limits = c(-0.2, 0.2)) +
  scale_x_continuous(limits = c(-0.2, 0.2)) +
  labs(y = "Observed Gene-Outcome Coefficient",
       title = "30% of 25 \nInstruments Invalid",
       caption = ""
  ) +
  theme(axis.title.y = element_blank())

test_plot_inval_0.5 <- test_plot_tib_inval_0.5 %>% 
  select(alpha, coeff_G_Y) %>% 
  plot_template() +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  aes(x = alpha, y = coeff_G_Y ) +
  scale_y_continuous(limits = c(-0.2, 0.2)) +
  scale_x_continuous(limits = c(-0.2, 0.2)) +
  labs(y = "Observed Gene-Outcome Coefficient",
       title = "50% of 25 \nInstruments Invalid",
       caption = "Pleiotropic effects range: -0.2 to 0.2") +
  theme(axis.title.y = element_blank())

plot_grid(test_plot_inval_0.1,
          test_plot_inval_0.3,
          test_plot_inval_0.5,
          ncol = 3,
          rel_widths = c(1.1, 1, 1))


```

\newpage
Similarly, with random error terms set to 0 (`rand_error = FALSE`) and no causal effect present (`causal_effect = FALSE`), gene-exposure coefficients estimated for each instrument should exactly match the actual values simulated, i.e. `coeff_G_X = gamma` for all instruments:

```{r test-plot-gamma-1, echo=FALSE, include = TRUE}

# Check observed gene-exposure coefficients for each instrument
# (coeff_G_X) approximate true values (gamma) when a causal effect 
# is present & a large number of participants are included 
#set.seed(1701)
sim_test_data_gamma_1 <- get_simulated_MR_data(n_participants = 100,
                                               n_instruments = 25,
                                               n_datasets = 1,
                                               prop_invalid = 0.1,
                                               causal_effect = FALSE,
                                               rand_error = FALSE,
                                               balanced_pleio = TRUE,
                                               InSIDE_satisfied = TRUE)


test_plot_tib_gamma_1 <- get_models(sim_test_data_gamma_1)[[1]] 

test_plot_tib_gamma_1 %>% 
  select(gamma, coeff_G_X) %>% 
  plot_template() +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  aes(x = gamma, y = coeff_G_X ) +
  labs(y = "Observed Gene-Exposure Coefficient",
       title = "Actual and Estimated Gene-Exposure Coefficients Match")

```

\newpage
### Gene-Exposure Coefficient Versus Gene-Outcome Coefficient Plots
\leavevmode\newline For the next phase of testing, a function (`plot_GY_GX`) was written to plot the coefficients for gene-exposure versus gene-outcome as estimated using the previously created linear models:

```{r plot-GY-GX-fn, echo=TRUE, include = TRUE}

plot_GY_GX <- function(model_tib, 
                       plot_title = as.character(NA),
                       x_min = 0,                     # set x-axis limits
                       x_max = 0.1,
                       y_min = -0.05,                 # set x-axis limits
                       y_max = 0.06,
                       beta_x = 0.075,                # set beta-hat position
                       beta_y = 0.05,
                       hat_offset = 0.003
)
{
  
  model_tib %>% 
    mutate(Gradient = round(coefficients(lm(coeff_G_Y ~ 0 + coeff_G_X)[1], 5), 
                            digits = 2)) %>%
    plot_template() + # pre-formatted plot template - call to ggplot with UoE colours
    aes(x = coeff_G_X, y = coeff_G_Y) +
    geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
    geom_abline(aes(intercept = 0, 
                    slope = Gradient),
                size = 1,
                colour = edin_uni_blue_hex) +
    geom_text(aes(label = paste0("\U03B2 = ", as.character(Gradient))), #beta
              x = beta_x, # labels with gradient (causal effect estimate)
              y = beta_y,
              colour = edin_uni_blue_hex, 
              hjust = 0, 
              data = . %>% slice_head()# prevent over-printing
    ) +
    #label = expression("True" ~ hat(beta)~ "= 0.25"),
    annotate("text",
             x = beta_x,      # add hat to beta
             y = beta_y + hat_offset,
             label = paste("\U02C6"),
             colour = edin_uni_blue_hex, 
             hjust = -0.4,
             vjust = 0.9
    ) +
    labs(title = plot_title,
         x = "Gene-Exposure Coefficient",
         y = "Gene-Outcome Coefficient") +
    xlim(x_min, x_max) +
    ylim(y_min, y_max)
  
}


```

\newpage
With random error terms set to 0 (`rand_error = FALSE`) and no causal effect present, a graph of gene-exposure coefficients versus gene-outcome coefficients should be a straight line through the origin with gradient = 0; causal effect of $\beta$ = 0.1  present (`beta_val = 0.1`, `causal_effect = TRUE`), the slope of a graph of gene-exposure coefficients versus gene-outcome coefficients from the same sample should be a straight line through the origin with gradient = 0.1:

```{r test-plot-causal, echo=FALSE, include = TRUE}

source(here::here("Script", "edin_fig_style.R"))
source(here::here("Script", "edin_uni_colours.R"))

# No causal effect present
#set.seed(1701)
sim_test_data_causal_0 <- get_simulated_MR_data(n_participants = 10000,
                                                n_instruments = 100,
                                                n_datasets = 1,
                                                prop_invalid = 0,
                                                causal_effect = FALSE,
                                                rand_error = FALSE)

test_plot_tib_causal_0 <- get_models(sim_test_data_causal_0)[[1]]

test_plot_causal_0 <- plot_GY_GX(test_plot_tib_causal_0, 
                                 plot_title = "No Causal Effect")

# Causal effect present
#set.seed(1701)
sim_test_data_causal_1 <- get_simulated_MR_data(n_participants = 10000,
                                                n_instruments = 100,
                                                n_datasets = 1,
                                                prop_invalid = 0, 
                                                beta_val = 0.1,
                                                causal_effect = TRUE,
                                                rand_error = FALSE,
                                                two_sample = FALSE)

test_plot_tib_causal_1 <- get_models(sim_test_data_causal_1)[[1]]

test_plot_causal_1 <- plot_GY_GX(test_plot_tib_causal_1, 
                                 plot_title = "Causal Effect Present")+
  theme(axis.title.y = element_blank())

plot_grid(test_plot_causal_0,
          test_plot_causal_1,
          ncol = 2,
          rel_widths = c(1.05, 1))



```


\newpage
### Random Errors
\leavevmode\newline Re-plotting the same graphs with non-zero random error terms (`rand_error = TRUE`) should produce similar graphs with Gaussian spread around lines passing through the origin with gradients of 0 and 0.1 for no causal effect and causal effect, respectively:

```{r test-plot-causal-errors, echo=FALSE, include = TRUE}


# Causal effect not present
#set.seed(1701)
sim_test_data_causal_0_errors <- get_simulated_MR_data(n_participants = 10000,
                                                       n_instruments = 100,
                                                       n_datasets = 1,
                                                       prop_invalid = 0,
                                                       causal_effect = FALSE,
                                                       rand_error = TRUE,
                                                       two_sample = FALSE)

test_plot_tib_causal_0_errors <- get_models(sim_test_data_causal_0_errors)[[1]]

test_plot_causal_0_errors <- plot_GY_GX(test_plot_tib_causal_0_errors, 
                                        plot_title = "No Causal Effect")

# Causal effect present
#set.seed(1701)
sim_test_data_causal_1_errors <- get_simulated_MR_data(n_participants = 10000,
                                                       n_instruments = 100,
                                                       n_datasets = 1,
                                                       prop_invalid = 0,
                                                       causal_effect = TRUE,
                                                       rand_error = TRUE,
                                                       two_sample = FALSE)

test_plot_tib_causal_1_errors <- get_models(sim_test_data_causal_1_errors)[[1]]

test_plot_causal_1_errors <-  plot_GY_GX(test_plot_tib_causal_1_errors, 
                                         plot_title = "Causal Effect Present") +
  theme(axis.title.y = element_blank())

plot_grid(test_plot_causal_0_errors,
          test_plot_causal_1_errors,
          ncol = 2,
          rel_widths = c(1.05, 1))
```

\newpage
### One versus Two Sample MR
\leavevmode\newline Where gene-exposure coefficients and gene-outcome coefficients are estimated from two separate samples rather than one (i.e. `two_sample = TRUE`, simulating 2 sample MR), even with random error terms set to zero, error will be introduced into causal effect estimation through random sampling of different combinations of effect alleles. However, where a causal effect is not present, the effect estimated will consistently be zero regardless of the combinations of alleles sampled, so random error should not be introduced:

```{r test-plot-causal-2SMR, echo=FALSE, cache=FALSE, include = TRUE}

source(here::here("Script", "edin_fig_style.R"))
source(here::here("Script", "edin_uni_colours.R"))

# Causal effect not present
#set.seed(1701)
sim_test_data_causal_0_2SMR <- get_simulated_MR_data(n_participants = 1000,
                                                     n_instruments = 100,
                                                     n_datasets = 1,
                                                     prop_invalid = 0,
                                                     causal_effect = FALSE,
                                                     rand_error = FALSE,
                                                     two_sample = TRUE)

test_plot_tib_causal_0_2SMR <- get_models(sim_test_data_causal_0_2SMR)[[1]]

test_plot_causal_0_2SMR <- plot_GY_GX(test_plot_tib_causal_0_2SMR, 
                                      plot_title = "No Causal Effect")

# Causal effect present
#set.seed(1701)
sim_test_data_causal_1_2SMR <- get_simulated_MR_data(n_participants = 1000,
                                                     n_instruments = 100,
                                                     n_datasets = 1,
                                                     prop_invalid = 0,
                                                     causal_effect = TRUE,
                                                     rand_error = FALSE,
                                                     two_sample = TRUE)

test_plot_tib_causal_1_2SMR <- get_models(sim_test_data_causal_1_2SMR)[[1]]

test_plot_causal_1_2SMR <- plot_GY_GX(test_plot_tib_causal_1_2SMR, 
                                      plot_title = "Causal Effect Present") +
  theme(axis.title.y = element_blank())

plot_grid(test_plot_causal_0_2SMR,
          test_plot_causal_1_2SMR,
          ncol = 2,
          rel_widths = c(1.05, 1))


```

\newpage
### Invalid Instruments 
\leavevmode\newline Where invalid instruments are present (i.e. `prop_invalid` $\ne$ `0`) and random error terms are set to 0, graphs of gene-exposure coefficients versus gene-outcome coefficients should be straight lines through the origin and all points representing valid instruments; the invalid instruments should appear as outliers to this line:

```{r test-plot-causal-inval, echo=FALSE, include = TRUE}


# Causal effect not present
#set.seed(1701)
sim_test_data_causal_0_inval <- get_simulated_MR_data(n_participants = 10000,
                                                      n_instruments = 100,
                                                      n_datasets = 1,
                                                      prop_invalid = 0.1,
                                                      causal_effect = FALSE,
                                                      rand_error = FALSE,
                                                      two_sample = FALSE)

test_plot_tib_causal_0_inval <- get_models(sim_test_data_causal_0_inval)[[1]]

test_plot_causal_0_inval <- plot_GY_GX(test_plot_tib_causal_0_inval, 
                                       plot_title = "No Causal Effect")

# Causal effect present
#set.seed(1701)
sim_test_data_causal_1_inval <- get_simulated_MR_data(n_participants = 10000,
                                                      n_instruments = 100,
                                                      n_datasets = 1,
                                                      prop_invalid = 0.1,
                                                      causal_effect = TRUE,
                                                      rand_error = FALSE,
                                                      two_sample = FALSE)

test_plot_tib_causal_1_inval <- get_models(sim_test_data_causal_1_inval)[[1]]

test_plot_causal_1_inval <- plot_GY_GX(test_plot_tib_causal_1_inval, 
                                       plot_title = "Causal Effect Present") +
  theme(axis.title.y = element_blank())

plot_grid(test_plot_causal_0_inval,
          test_plot_causal_1_inval,
          ncol = 2,
          rel_widths = c(1.05, 1))


```

\newpage
### Balanced Versus Directional Pleiotropy
\leavevmode\newline Replotting the above with unbalanced pleiotropy present (`balanced_pleio = FALSE`), the invalid instruments should all appear as outliers in the positive direction, i.e. steepening the line of best fit and leading to overestimation of the causal effect: 

```{r test-plot-causal-unbal, echo=FALSE, include = TRUE}


# Causal effect not present
#set.seed(1701)
sim_test_data_causal_0_unbal <- get_simulated_MR_data(n_participants = 10000,
                                                      n_instruments = 100,
                                                      n_datasets = 1,
                                                      prop_invalid = 0.2,
                                                      causal_effect = FALSE,
                                                      rand_error = FALSE, 
                                                      balanced_pleio = FALSE,
                                                      two_sample = FALSE)

test_plot_tib_causal_0_unbal <- get_models(sim_test_data_causal_0_unbal)[[1]]

test_plot_causal_0_unbal <- plot_GY_GX(test_plot_tib_causal_0_unbal, 
                                       plot_title = "No Causal Effect")

# Causal effect present
#set.seed(1701)
sim_test_data_causal_1_unbal <- get_simulated_MR_data(n_participants = 10000,
                                                      n_instruments = 100,
                                                      n_datasets = 1,
                                                      prop_invalid = 0.2,
                                                      causal_effect = TRUE,
                                                      rand_error = FALSE,
                                                      balanced_pleio = FALSE,
                                                      two_sample = FALSE)

test_plot_tib_causal_1_unbal <- get_models(sim_test_data_causal_1_unbal)[[1]]

test_plot_causal_1_unbal <- plot_GY_GX(test_plot_tib_causal_1_unbal, 
                                       plot_title = "Causal Effect Present") +
  theme(axis.title.y = element_blank())

plot_grid(test_plot_causal_0_unbal,
          test_plot_causal_1_unbal,
          ncol = 2,
          rel_widths = c(1.05, 1))


```
<!-- https://pmc.ncbi.nlm.nih.gov/articles/PMC4469799/ -->
<!-- https://mr-dictionary.mrcieu.ac.uk/term/inside/ -->

\newpage
### InSIDE Assumption and Phi
\leavevmode\newline The variable phi represents additional pleiotropic effects of each invalid instrument when the \acr{InSIDE} assumption is not satisfied. The \acr{InSIDE} assumption states that the gene-exposure association is not correlated with the pleiotropic path gene-outcome path of any invalid genetic instruments. This assumption can be violated if e.g.:

- several invalid genetic instruments influence the outcome via the same pleiotropic path

- several invalid genetic instruments are related to the same (unmeasured) confounders of the exposure:outcome relationship, aka correlated pleiotropy. 

As such, when the \acr{InSIDE} assumption is violated, even "strong" instruments (i.e. those with a strong gene-exposure relationship) may not allow accurate estimation of the true causal effect, as pleiotropic effects may scale with instrument strength. If pleiotropic effects are balanced, InSIDE assumption violation may lead to greater imprecision in causal effect estimation; if pleiotropic effects are directional, \acr{InSIDE} assumption violation may lead to bias.

Bowden et al [@bowden_consistent_2016] modeled phi as the pleiotropic effects of unmeasured genetic confounders of the exposure:outcome relationship.  Phi adds additional error to causal effect estimation in scenarios with directional pleiotropic effects (`0 < alpha < 0.2`) and \acr{InSIDE} assumption violation. As such, switching `InSIDE_satisfied` from `TRUE` to `FALSE` should add scatter to the linear association expected when plotting alpha versus gene-outcome coefficients with random error terms set to zero:


```{r test-plot-phi, echo=FALSE, include = TRUE}

# Check violating InSIDE assumption results in distorted 
# estimation of pleiotropic effects
# N.B. cluster around alpha = 0 represents valid instruments with
# no pleiotropic effects
#set.seed(1701)
sim_test_data_phi_0 <- get_simulated_MR_data(n_participants = 100000,
                                             n_instruments = 100,
                                             n_datasets = 1,
                                             prop_invalid = 0.3,
                                             causal_effect = FALSE,
                                             rand_error = FALSE, 
                                             balanced_pleio = FALSE,
                                             InSIDE_satisfied = TRUE)


#set.seed(1701)
sim_test_data_phi_1 <- get_simulated_MR_data(n_participants = 100000,
                                             n_instruments = 100,
                                             n_datasets = 1,
                                             prop_invalid = 0.3,
                                             causal_effect = FALSE,
                                             rand_error = FALSE, 
                                             balanced_pleio = FALSE,
                                             InSIDE_satisfied = FALSE)



test_plot_tib_phi_0 <- get_models(sim_test_data_phi_0)[[1]]
test_plot_tib_phi_1 <- get_models(sim_test_data_phi_1)[[1]]

test_plot_phi_0 <- test_plot_tib_phi_0 %>%
  plot_template() +
  aes(x = alpha, y = coeff_G_Y) +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  labs(title = "InSIDE Not Violated",
       y = "Gene-Outcome Coefficient")


test_plot_phi_1 <- test_plot_tib_phi_1 %>%
  plot_template() +
  aes(x = alpha, y = coeff_G_Y) +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  labs(title = "InSIDE Violated",
       y = "Gene-Outcome Coefficient") +
  theme(axis.title.y = element_blank())


plot_grid(test_plot_phi_0,
          test_plot_phi_1,
          ncol = 2,
          rel_widths = c(1.05, 1))



```

\newpage
Setting `InSIDE_satisfied = TRUE` should mean `phi = 0`; `InSIDE_satisfied=FALSE` should result in `phi` $\propto$ gene-outcome coefficient, with scatter only in the positive direction of gene-outcome coefficients given the model also requires directional pleiotropy before `phi` is used:


```{r test-plot-phi-2, echo=FALSE, include = TRUE}

# Check violating InSIDE assumption results in distorted 
# estimation of pleiotropic effects
# N.B. cluster around alpha = 0 represents valid instruments with
# no pleiotropic effects
#set.seed(1701)
sim_test_data_phi_0 <- get_simulated_MR_data(n_participants = 100000,
                                             n_instruments = 100,
                                             n_datasets = 1,
                                             prop_invalid = 0.3,
                                             causal_effect = FALSE,
                                             rand_error = FALSE, 
                                             balanced_pleio = FALSE,
                                             InSIDE_satisfied = TRUE)


#set.seed(1701)
sim_test_data_phi_1 <- get_simulated_MR_data(n_participants = 100000,
                                             n_instruments = 100,
                                             n_datasets = 1,
                                             prop_invalid = 0.3,
                                             causal_effect = FALSE,
                                             rand_error = FALSE, 
                                             balanced_pleio = FALSE,
                                             InSIDE_satisfied = FALSE)



test_plot_tib_phi_0 <- get_models(sim_test_data_phi_0)[[1]]
test_plot_tib_phi_1 <- get_models(sim_test_data_phi_1)[[1]]

test_plot_phi_0 <- test_plot_tib_phi_0 %>%
  plot_template() +
  aes(x = phi, y = coeff_G_Y) +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  labs(title = "InSIDE Not Violated",
       y = "Gene-Outcome Coefficient")


test_plot_phi_1 <- test_plot_tib_phi_1 %>%
  plot_template() +
  aes(x = phi, y = coeff_G_Y) +
  geom_point(colour = edin_bright_red_hex, alpha = 0.3) +
  labs(title = "InSIDE Violated",
       y = "Gene-Outcome Coefficient") +
  theme(axis.title.y = element_blank())


plot_grid(test_plot_phi_0,
          test_plot_phi_1,
          ncol = 2,
          rel_widths = c(1.05, 1))

```

\newpage
## Summary Table {#appendix-sim-summ}

A function (`get_summary_MR_tib_row`) was written to take models generated from each simulated dataset, estimate causal effect using both weighted median and MR-Hevo methodologies, then output a summary formatted as per Tables 2 & 3 in Bowden et al [@bowden_consistent_2016]:



```{r summary-MR-tib-row-fn, echo=TRUE, include = TRUE}

# Load WME functions
library(TwoSampleMR)

# Load RStan - needed for MR-Hevo
library(rstan)


# Run local copy of MR-Hevo functions
# Not using full package due to conflicts with Windows
source(here::here("Script", "Hevo", "functions.mrhevo.R"))

# Standard set-up for RStan
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE, save_dso = TRUE)


# Compile model for MR-Hevo
mr.stanmodel <- stan_model(file= here::here("Script", 
                                      "Hevo", 
                                      "MRHevo_summarystats.stan"),
                           model_name="MRHevo.summarystats", 
                           verbose=FALSE,
                           save_dso = TRUE,
                           auto_write = TRUE)

get_summary_MR_tib_row <- function(model_list){
  
  
  # Create output tibble in same format as Table 2/3 from
  # Bowden et al
  output_tib_row <- tibble(N = as.integer(),
                           Prop_Invalid = as.double(),
                           F_stat = as.double(),
                           R2_stat = as.double(),
                           WME_Av = as.double(),
                           WME_SE = as.double(),
                           WME_Pos_Rate = as.double(),
                           Hevo_Av = as.double(),
                           Hevo_SE = as.double(),
                           Hevo_Pos_Rate = as.double())
  
  n_datasets <- length(model_list)
  
  # Create blank tibble to receive results of Weighted
  # Median Estimator function from MR-Base
  
  results_tib <-  tibble(WME_est = as.double(),
                         WME_se = as.double(),
                         WME_pval = as.double(),
                         WME_nsnp = as.integer(),
                         Hevo_est = as.double(),
                         Hevo_se = as.double(),
                         Hevo_sd = as.double(),
                         Hevo_est_lower_CI = as.double(),
                         Hevo_est_upper_CI = as.double(),
                         Hevo_causal_detected = as.logical()
  )
  
  
  # Run WME and MR-Hevo for each dataset 
  for(dataset in 1:n_datasets){
    
    # Stored as individual vectors for MR-Hevo/RStan - not
    # Tidyverse compatible
    coeff_G_X_vect <- model_list[[dataset]]$coeff_G_X
    coeff_G_Y_vect <- model_list[[dataset]]$coeff_G_Y
    coeff_G_X_SE_vect <- model_list[[dataset]]$coeff_G_X_SE
    coeff_G_Y_SE_vect <- model_list[[dataset]]$coeff_G_Y_SE
    prop_invalid <- min(model_list[[dataset]]$prop_invalid)
    F_stat <- min(model_list[[dataset]]$F_stat)
    R2_stat <- min(model_list[[dataset]]$R2_stat)
    n_instruments <- max(model_list[[dataset]]$Instrument)
    n_participants <- min(model_list[[dataset]]$n_participants)
    
    
    # N.B. MR-Hevo terminology vs WME paper/other code:
    # alpha = effects of instruments on exposure, i.e. coeff_G_X
    # beta = pleiotropic effects of instruments on outcome, i.e. alpha in WME
    # gamma = effects of instruments on outcome, i.e. coeff_G_Y
    # theta = causal effect X on Y, i.e. b
    
    # Results from weighted median estimator method
    WME_results <- mr_weighted_median(b_exp = coeff_G_X_vect,
                                      b_out = coeff_G_Y_vect,
                                      se_exp = coeff_G_X_SE_vect,
                                      se_out = coeff_G_Y_SE_vect,
                                      parameters = list(nboot = 1000))
    
    # Results from MR-Hevo method
    Hevo_results<- run_mrhevo.sstats(alpha_hat = coeff_G_X_vect,
                                    se.alpha_hat = coeff_G_X_SE_vect,
                                    gamma_hat = coeff_G_Y_vect,
                                    se.gamma_hat = coeff_G_Y_SE_vect) %>%
     summary()
    
    
    # Extract WME Results
    results_tib[dataset, ]$WME_est <- WME_results$b
    results_tib[dataset, ]$WME_se <- WME_results$se
    results_tib[dataset, ]$WME_pval <- WME_results$pval
    results_tib[dataset, ]$WME_nsnp <- WME_results$nsnp
    
    # Extract MR-Hevo Results
    results_tib[dataset, ]$Hevo_est <- Hevo_results$summary["theta","mean"]
    results_tib[dataset, ]$Hevo_se <- Hevo_results$summary["theta","se_mean"] # Used in error - actually Monte Carlo SE
    results_tib[dataset, ]$Hevo_sd <- Hevo_results$summary["theta","sd"] # Should have been used as SE - SD of bootstrap distribution
    results_tib[dataset, ]$Hevo_est_lower_CI <- Hevo_results$summary["theta","2.5%"]
    results_tib[dataset, ]$Hevo_est_upper_CI <- Hevo_results$summary["theta","97.5%"]
    
  }
  
  # Add causality Boolean to MR-Hevo
  results_tib <- results_tib %>%
   mutate(Hevo_est_causal_detected = (Hevo_est_lower_CI > 0  | Hevo_est_upper_CI < 0))
  
  
  output_tib_row <- results_tib %>% 
    summarise(N = n_participants,
              Prop_Invalid = prop_invalid,
              F_stat = mean(F_stat),
              R2_stat = mean(R2_stat),
              WME_Av = mean(WME_est),
              WME_SE = mean(WME_se),
              WME_Pos_Rate = length(WME_pval[WME_pval < 0.05]) / n_datasets,
              Hevo_Av = mean(Hevo_est),
              Hevo_SE = mean(Hevo_se),
              Hevo_Lower_CI = mean(Hevo_est_lower_CI),
              Hevo_Upper_CI = mean(Hevo_est_upper_CI),
              Hevo_Pos_Rate = sum(Hevo_est_causal_detected) / n_datasets
    ) %>% 
    mutate(across(where::here(is.double), round, 3))
  
  return(output_tib_row)
  
}



```

```{r load-functions-sneaky, echo = FALSE}

# test-summary-MR-tib-row-fn doesn't work without reloading functions here
# does work when all relevant code copy/pasted to test script - ?bugged
# Error code:
# Error in `h()`:
# ! error in evaluating the argument 'object' in selecting a method for function 'summary': could not find function "set.tau0"
# or sometimes:
# ! error in evaluating the argument 'object' in selecting a method for function 'summary': error in evaluating the argument 'object' in selecting a method for function 'sampling': object 'mr.stanmodel' not found

# Load function scripts
source(here::here("Script", "simulation_functions.R"))

# Run local copy of MR-Hevo functions
# Not using full package due to conflicts with Windows
source(here::here("Script", "Hevo", "functions.mrhevo.R"))

```

```{r test-summary-MR-tib-row-fn, echo=TRUE, include = TRUE}

test_tib_summ_MR_data <-  get_simulated_MR_data(n_participants = 10000,
                                                n_instruments = 25,
                                                n_datasets = 2,
                                                prop_invalid = 0.1,
                                                beta_val = 0.1,
                                                causal_effect = TRUE,
                                                rand_error = TRUE,
                                                two_sample = TRUE,
                                                balanced_pleio = TRUE,
                                                InSIDE_satisfied = TRUE)

test_tib_summ_MR_models <- get_models(test_tib_summ_MR_data)

test_tib_summ_MR_row <- get_summary_MR_tib_row(test_tib_summ_MR_models)

test_tib_summ_MR_row %>% 
  kable() %>% 
  kable_styling(latex_options="scale_down")

```



\newpage

# Appendix: R Packages Used {#appendix-pkg}

## Package Citations

```{r package-citations, include = TRUE, echo = FALSE}

#nocite_references(cite_packages(output = "citekeys", out.dir = tempdir()))

grateful::cite_packages(output = "paragraph",
                        passive.voice = TRUE,
                        out.dir = here::here(),
                        omit = NULL,
                        include.RStudio = FALSE) 
  #gt() %>% 
  #fmt_markdown()

  #kable() %>% 
  #kable_styling() %>% 
  #unclass() %>% 
  #cat()
  #str_replace_all(pattern = ",", "\n") #%>% 
  #cat() %>% 
  #return()
  #tibble() %>%
  #mutate(Citation = paste0("[", Citation, "]")) %>%
  #knitr::kable()

  
```

## Session Information {#Session-Information}


```{r system-info, include = TRUE, echo = FALSE}

library(benchmarkme)

sys_details_full <- benchmarkme::get_sys_details()

sysname_release <- paste0(sys_details_full$sys_info, " ", sys_details_full$release)

sys_ram <- sys_details_full$ram
sys_cpu <- sys_details_full$cpu$model_name
sys_cores <- sys_details_full$cpu$no_of_cores

```

CPU: `r sys_cpu`, `r sys_cores` cores \newline
RAM: `r (sys_ram * 10^-9) %>% format(scientific = FALSE) %>% as.numeric() %>%  round(., 1)` GB

```{r session-info, include=TRUE, echo=FALSE}

platform <- devtools::session_info() %>% #str()
  .$platform

packages <- devtools::session_info() %>%
  .$packages %>%
  tibble() %>%
  filter(attached == TRUE) %>%
  select(-c(path,
            loadedpath,
            attached,
            is_base,
            md5ok,
            library))

package_col <- packages$package

# package_col %>%
#   map(citation) %>%
#   #print()
#   print(style = "BibTeX")
#   #print(style = "text")

platform

packages %>% 
  print(n = nrow(.))

```

\newpage